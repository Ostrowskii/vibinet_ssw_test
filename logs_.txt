commit 794f566093ecb770c502e006dd5ce2df96f3bb90
Author: VictorTaelin <victortaelin@gmail.com>
Date:   Tue Nov 4 17:54:55 2025 -0300

    state_machine: factor official_time/official_tick helpers and use everywhere; walkers: compute PIXELS_PER_TICK from TICKS_PER_SECOND to avoid magic number

commit dac02b5172e26866bcdbb6103de952501050dc04
Author: VictorTaelin <victortaelin@gmail.com>
Date:   Tue Nov 4 17:49:53 2025 -0300

    gitignore: ignore local '.stuff/' cache directory

commit c1895f0b4801ccb9580f74ca75d0fe232cdacba8
Author: VictorTaelin <victortaelin@gmail.com>
Date:   Tue Nov 4 17:47:19 2025 -0300

    cleanup: remove accidental '.stuff' from repo; ignore it in .gitignore

commit 3266fb705320e9f6ded1909f7a9bb65e6658449a
Author: VictorTaelin <victortaelin@gmail.com>
Date:   Tue Nov 4 17:46:55 2025 -0300

    cleanup: remove legacy walkers build/serve scripts; update README; align initial_tick with official_time of index 0 to avoid missing early posts

commit 9aa1d91c0d2ae856d1f749661fab97950f7f7069
Author: VictorTaelin <victortaelin@gmail.com>
Date:   Tue Nov 4 17:44:38 2025 -0300

    rename 'letters' to 'walkers'; unify server: HTTP static + WebSocket on same port 8080; auto-build walkers bundle on server start; simplify scripts to single 'server'

commit 4038b2be3b21223dfebcad189296ecaf79326733
Author: VictorTaelin <victortaelin@gmail.com>
Date:   Tue Nov 4 17:37:48 2025 -0300

    letters: pin spawn to (200,200) in logic and UI. client: add exported send() wrapper and register_handler helper to reduce duplication; all client API calls use send().

commit 59e9befd4a2762cebfb9858f6f99d11a664f46a4
Author: VictorTaelin <victortaelin@gmail.com>
Date:   Tue Nov 4 17:34:49 2025 -0300

    client: remove send() queue/deferral; throw if ws not open; fire immediate get_time on connect; server_time throws pre-sync. state_machine: wait for on_sync, then watch+load; add concise post-recv logs. letters: log spawn on sync.

commit 7a7e31325cb0a4d5e08d85556e689092f42ffd8e
Author: VictorTaelin <victortaelin@gmail.com>
Date:   Tue Nov 4 17:25:32 2025 -0300

    client: add on_sync event; remove pending queue; require sync for server_time; letters: wait for sync before spawn/input/render and show server_time overlay; switch on_post to switch-case

commit dd309eac772b2a33a82e0f2a86f53a9ef2a2c272
Author: VictorTaelin <victortaelin@gmail.com>
Date:   Tue Nov 4 16:27:14 2025 -0300

    Auto-detect WebSocket server hostname for local and remote deployment
    
    Changed WebSocket connection from hardcoded localhost to dynamically use
    window.location.hostname. This allows the game to work seamlessly in both
    development (localhost) and production (remote IP/domain) environments
    without requiring configuration changes.
    
    ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

commit 3223417f47f09ab973f683ffb8a54fa522f5dc1f
Author: VictorTaelin <victortaelin@gmail.com>
Date:   Tue Nov 4 16:08:00 2025 -0300

    Add auto-cleanup for server processes on restart
    
    Implement automatic process cleanup to prevent "port in use" errors:
    
    - Save PID to file when server starts (.server.pid, .serve.pid)
    - On startup, check for existing PID and kill previous process
    - Wait 100ms for port to be released before starting new server
    - Add PID files to .gitignore
    
    This allows running `bun run server` or `bun run letters:serve`
    multiple times without manually killing previous processes.
    
    Usage:
    - Just run `bun run server` again - it auto-kills the previous one
    - Same for `bun run letters:serve`
    
    ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

commit bb86e1a366d91f0de9716e94f738f6b3897b9e2c
Author: VictorTaelin <victortaelin@gmail.com>
Date:   Tue Nov 4 16:01:29 2025 -0300

    Refactor: Clean up codebase structure and eliminate duplication
    
    Major cleanup to remove repetitive files and organize the project structure:
    
    - Consolidate client.ts to root (browser version only)
    - Remove duplicate state_machine.ts copies (kept only in root)
    - Reorganize letters/ directory:
      - letters.ts â†’ letters/index.ts (game logic only)
      - Compile outputs now go to letters/dist/
      - Keep only source files in main directory
    - Update imports to reference parent directory modules
    - Add letters/dist/ to .gitignore
    
    Structure after cleanup:
    - Root: client.ts, state_machine.ts (shared browser modules)
    - letters/: index.ts, index.html, build.sh, serve.ts, README.md
    - letters/dist/: compiled JavaScript (not versioned)
    
    This eliminates 3 copies of state_machine.ts and properly separates
    source code from compiled artifacts.
    
    ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

commit ab032ae67052e128bfa85b1b3d00542d81935efb
Author: VictorTaelin <victortaelin@gmail.com>
Date:   Tue Nov 4 15:55:15 2025 -0300

    Add Letters multiplayer game demo using StateMachine
    
    Implement a browser-based multiplayer game where players control letters
    that move in 2D space, demonstrating the StateMachine system's capabilities
    for deterministic state synchronization across clients.
    
    Features:
    - Browser-based gameplay with HTML5 Canvas
    - Real-time multiplayer synchronization via WebSocket
    - WASD movement controls with 200 pixels/second speed
    - Runs at 24 ticks/second with 100ms tolerance
    - Client-side state computation ensures all players see consistent state
    
    Implementation:
    - Extend StateMachine with post() and compute_current_state() methods
    - Fix time_to_tick() calculation for correct tick semantics
    - Create client_web.ts for browser-compatible WebSocket client
    - Add HTTP server (serve.ts) for serving game files
    - Build system using Bun for TypeScript compilation
    
    Game Structure:
    - State: Map of character â†’ {position, WASD key states}
    - on_tick: Updates player positions based on key states
    - on_post: Handles spawn, keydown, and keyup events
    - Immutable state updates throughout
    
    ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

commit be121fa64da4c7a33d125d7db2cd103780b98cf9
Author: VictorTaelin <victortaelin@gmail.com>
Date:   Tue Nov 4 14:40:33 2025 -0300

    Rename StateMachine.ts to state_machine.ts

commit aa37fd58cf4ac6414ae01235de1cfe8c76861679
Author: VictorTaelin <victortaelin@gmail.com>
Date:   Tue Nov 4 14:39:07 2025 -0300

    Fix load() to display messages and prevent duplicate handlers
    
    **Changes to client.ts:**
    - Made load() accept optional handler parameter
    - Made watch() handler parameter optional
    - Both functions now check if handler already registered for room
    - Throws descriptive error: "Handler already registered for room: {room}"
    - This prevents accidentally overwriting existing room handlers
    
    **Changes to client_cli.ts:**
    - Updated /load command to pass handler callback
    - Now displays info_post messages when loading room history
    - Fixes bug where /load command showed nothing despite server sending data
    
    This ensures both load and watch can optionally register handlers while
    preventing duplicate registrations that could cause unexpected behavior.
    
    ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

commit aeee74ab915e32bd430248941270ef6fcfa836f6
Author: VictorTaelin <victortaelin@gmail.com>
Date:   Tue Nov 4 14:30:48 2025 -0300

    Add StateMachine for deterministic state computation
    
    This commit implements a StateMachine class that computes deterministic
    game/app state from a sequence of posts in a room, using a tick-based
    system with time synchronization.
    
    ## Architecture Changes
    
    **Refactored client.ts into library API:**
    - Split client.ts into pure library (client.ts) and CLI interface (client_cli.ts)
    - client.ts exports: post(), load(), watch(), unwatch(), server_time(), close()
    - watch() now accepts a callback parameter instead of global on_message()
    - Callbacks are stored per-room in a Map, called when info_post is received
    - Updated package.json to run client_cli.ts for the "client" script
    
    **Created client_cli.ts:**
    - Interactive REPL interface using readline
    - Commands: /post, /load, /watch, /unwatch
    - Imports and uses client.ts library functions
    
    ## StateMachine Implementation
    
    **Constructor parameters:**
    - room: string - 48-bit room name where posts are processed
    - init: S - initial state of the game/app
    - on_tick: (state: S) => S - function called every tick
    - on_post: (post: P, state: S) => S - function to process user posts
    - ticks_per_second: number - number of ticks per second
    - tolerance: number - how far in past (ms) to tolerate posts
    
    **Fields:**
    - room_posts: Map<number, Post<P>> - maps post index to post data
    - Automatically watches room and loads all existing posts on construction
    
    **Methods:**
    - time_to_tick(server_time) - converts time to tick: floor(server_time/ticks_per_second)
    - server_time() - returns current server time (re-exported from client.ts)
    - server_tick() - returns current server tick
    - initial_time() - returns server_time of post at index 0, or null if no posts
    - initial_tick() - returns tick of first post, or null if no posts
    - compute_state_at(at_tick) - computes state at a given tick
    
    ## compute_state_at Algorithm
    
    1. Returns init if no posts exist or if at_tick < initial_tick
    2. Builds timeline: Map from tick to array of posts
    3. For each post, calculates "official_time" using tolerance:
       - If client_time <= server_time - tolerance: official_time = server_time - tolerance
       - Otherwise: official_time = client_time
       - This prevents players from sending posts "in the past" to gain unfair advantages
    4. Converts official_time to official_tick and adds post to timeline
    5. Sorts posts within each tick by index for deterministic ordering
    6. Iterates from initial_tick to at_tick:
       - Applies on_tick(state) for each tick
       - Applies on_post(post.data, state) for all posts in that tick
    7. Returns final computed state
    
    This design ensures all clients compute identical state from the same post
    sequence, enabling deterministic multiplayer games and distributed apps.
    
    ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

commit 98bd1ff81b459c233887d23504843f1e490508f6
Author: VictorTaelin <victortaelin@gmail.com>
Date:   Tue Nov 4 11:50:05 2025 -0300

    Add real-time room watching with watch/unwatch functionality
    
    Implement a pub/sub system where clients can subscribe to rooms and receive real-time notifications when messages are posted.
    
    ## New Protocol Messages
    
    Client â†’ Server:
    - `{$:"watch", room: string}` - Subscribe to a room to receive real-time posts
    - `{$:"unwatch", room: string}` - Unsubscribe from a room
    
    When a client watches a room, they receive `info_post` messages immediately when anyone posts to that room (including themselves).
    
    ## Server Implementation
    
    **Watcher Tracking:**
    - Added `watchers: Map<string, Set<WebSocket>>` to track which clients are watching each room
    - Uses `Set<WebSocket>` to prevent duplicate subscriptions
      - Set uses object reference identity, so each WebSocket connection is unique
      - Multiple `add(ws)` calls with the same WebSocket only keep one entry
    
    **Watch Handler:**
    - Creates Set for room if it doesn't exist
    - Adds the WebSocket to the room's watcher Set
    - Logs "Watching: {room}" for debugging
    
    **Unwatch Handler:**
    - Removes WebSocket from room's watcher Set
    - Cleans up empty Sets (removes room entry when no watchers remain)
    - Logs "Unwatching: {room}" for debugging
    
    **Post Broadcasting:**
    - After saving a post to disk, broadcasts `info_post` to all watchers
    - Calculates correct index before appending (counts existing lines)
    - Sends complete message with: room, index, server_time, client_time, data
    - All watchers receive the post, including the sender
    
    **Connection Cleanup:**
    - Added `ws.on("close")` handler to remove disconnected clients from all watcher Sets
    - Prevents memory leaks and zombie subscriptions
    - Cleans up empty Sets automatically
    
    ## Client Implementation
    
    **New Commands:**
    - `/watch RoomName` - Start watching a room for real-time updates
    - `/unwatch RoomName` - Stop watching a room
    
    The existing `info_post` handler already prints received messages, so real-time posts are automatically displayed as formatted JSON.
    
    ## Usage Example
    
    Terminal 1 (watching):
    ```
    > /watch ChatRoom
    ```
    
    Terminal 2 (posting):
    ```
    > /post ChatRoom {"user":"Alice","msg":"Hello!"}
    ```
    
    Terminal 1 will immediately receive and print:
    ```json
    {
      "$": "info_post",
      "room": "ChatRoom",
      "index": 0,
      "server_time": 1234567890,
      "client_time": 1234567891,
      "data": {"user":"Alice","msg":"Hello!"}
    }
    ```
    
    Multiple clients can watch the same room simultaneously, creating a real-time chat experience.
    
    ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

commit 6599a751bd246fbded33a42a637f8484615f68d3
Author: VictorTaelin <victortaelin@gmail.com>
Date:   Tue Nov 4 11:35:00 2025 -0300

    Build TypeScript WebSocket application with time sync and room messaging
    
    Create a complete WebSocket-based client-server application in TypeScript with clock synchronization and a persistent room-based messaging system.
    
    ## Project Setup
    
    - Modern TypeScript configuration with ESNext target and bundler module resolution
    - ES modules (type: "module" in package.json)
    - Uses Bun runtime for fast execution
    - Dependencies: ws (WebSocket library) and @types/ws
    
    ## Time Synchronization System
    
    The client continuously estimates the clock offset between its local clock and the server clock using a ping-based algorithm.
    
    ### TimeSync State
    
    The client maintains a `TimeSync` object with three fields:
    - `clock_offset`: Difference between server clock and local clock (in ms)
    - `lowest_ping`: Best (lowest) round-trip time achieved so far
    - `request_sent_at`: Timestamp when the last get_time request was sent
    
    ### Synchronization Protocol
    
    Every 2 seconds, the client:
    1. Records current time as `request_sent_at`
    2. Sends `{$:"get_time"}` to server
    3. Server responds with `{$:"info_time", time: <server_timestamp>}`
    4. Client calculates ping = (current_time - request_sent_at)
    5. If this ping is lower than `lowest_ping`:
       - Calculate average time during round trip: `(request_sent_at + current_time) / 2`
       - Calculate clock offset: `server_time - local_avg_time`
       - Update `clock_offset` and `lowest_ping`
    
    This approach uses the lowest-ping measurements for better accuracy, assuming network jitter affects higher pings more than lower ones.
    
    ### Integer Timestamps
    
    All timestamps are integers (no fractional milliseconds) to keep data clean:
    - Both client and server use a `now()` helper: `Math.floor(Date.now())`
    - The `server_time()` function also returns floored integers
    - Clock offset calculations use `Math.floor()` for averages
    - Server floors incoming client_time values when persisting
    
    ## Room-Based Messaging System
    
    ### Room Identifiers
    
    Rooms use 48-bit IDs encoded with 6-bit characters from the alphabet:
    `"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-"`
    
    This creates readable 8-character room names (8 * 6 = 48 bits).
    
    ### Storage Format
    
    Messages are persisted to disk in `./db/{RoomName}.jsonl` where each line is a JSON object:
    ```json
    {"server_time": 1234567890, "client_time": 1234567891, "data": {...}}
    ```
    
    - `server_time`: Actual server timestamp when post was received (ground truth)
    - `client_time`: Client's estimate of server time when sending (for drift analysis)
    - `data`: The message payload (any valid JSON)
    
    The message index is not stored but inferred from line numbers (0-based). When loading, the server enriches messages with the index field.
    
    ### Message Protocol
    
    Client â†’ Server:
    
    `{$:"post", room: string, time: number, data: any}`
    - Post a message to a room
    - `room`: Room identifier
    - `time`: Client's estimated server time at send moment
    - `data`: Any valid JSON payload
    
    `{$:"load", room: string, from: number}`
    - Load messages from a room
    - `room`: Room identifier
    - `from`: Starting index (0-based), defaults to 0 if not provided
    
    Server â†’ Client:
    
    `{$:"info_post", room: string, index: number, server_time: number, client_time: number, data: any}`
    - Information about a post
    - `room`: Room identifier
    - `index`: Message index (line number in the file)
    - `server_time`: True server time when post was received
    - `client_time`: Client's estimated server time when posting
    - `data`: The message payload
    
    ### Server Implementation
    
    - Creates `./db/` directory if it doesn't exist
    - On `post`: Appends JSON line to room's .jsonl file, logs for debugging
    - On `load`: Reads file, sends each line as `info_post` starting from `from` index
    - Uses for-loop instead of forEach for better control and performance
    - Validates indices with `Math.max(0, from || 0)` to handle invalid input
    - Checks line existence with `if (line && line.trim())` to avoid crashes
    
    ### Client Implementation
    
    The client uses Node.js `readline` for an interactive REPL interface:
    
    - Shows a `>` prompt for user input
    - Continuously syncs time with server in background
    - Handles commands with switch statement for consistency
    
    Commands:
    - `/post RoomName {"key":"value"}` - Post a JSON message to a room
    - `/load RoomName [from]` - Load messages from index (defaults to 0)
    
    The client handles Ctrl-C (SIGINT) and Ctrl-Z (SIGTSTP) to exit gracefully, closing the WebSocket connection before exiting.
    
    Command parsing:
    - Splits input by spaces
    - Extracts room name from parts[1]
    - For `/post`: Joins remaining parts as JSON string and parses
    - For `/load`: Parses index from parts[2] with `parseInt() || 0` fallback
    
    When receiving `info_post` messages, the client prints them as formatted JSON.
    
    ## Code Style & Best Practices
    
    - Switch statements for all message type handling (consistent pattern)
    - Early return in error cases to reduce indentation
    - Aligned variable declarations (e.g., `const room = ...`, `const data = ...`)
    - Short variable names where they fit the alignment pattern
    - Simple, surgical changes using helper functions like `now()`
    - Robust error handling: validates inputs, provides defaults
    - Added db/ to .gitignore to avoid committing message data
    
    ## Usage
    
    Start server:
    ```bash
    bun run server.ts
    ```
    
    Start interactive client:
    ```bash
    bun run client.ts
    ```
    
    Then use commands like:
    ```
    > /post TestRoom {"message":"Hello, World!"}
    > /load TestRoom 0
    ```
    
    ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>
